@page "/"
@using Markdig
@using RockBot.UserProxy.Blazor.Services
@using Microsoft.JSInterop
@inject UserProxyService ProxyService
@inject ChatStateService ChatState
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>RockBot Chat</PageTitle>

<div class="chat-container d-flex flex-column vh-100">
    <div class="chat-header bg-primary text-white p-3 d-flex justify-content-between align-items-center">
        <h1 class="h4 mb-0">RockBot Chat</h1>
        <div class="d-flex align-items-center gap-2">
            <span class="connection-dot @(ProxyService.IsConnected ? "connected" : "disconnected")"
                  title="@(ProxyService.IsConnected ? "Connected to message bus" : "Disconnected from message bus")"></span>
            <button class="btn btn-sm btn-outline-light" @onclick="ToggleDarkMode" title="Toggle dark/light mode">
                @(IsDarkMode ? "‚òÄÔ∏è" : "üåô")
            </button>
        </div>
    </div>

    <div class="chat-messages flex-grow-1 overflow-auto p-3" @ref="messagesContainer">
        @foreach (var message in ChatState.Messages)
        {
            <div class="message-wrapper mb-3 @(message.IsFromUser ? "user-message" : "agent-message")">
                <div class="message-bubble p-3 rounded @(message.IsError ? "bg-danger text-white" : (message.IsFromUser ? "bg-primary text-white" : ""))">
                    @if (!message.IsFromUser && !message.IsError && !string.IsNullOrEmpty(message.AgentName))
                    {
                        <div class="fw-bold small mb-2">@message.AgentName</div>
                    }
                    <div class="message-content">
                        @((MarkupString)ConvertMarkdownToHtml(message.Content))
                    </div>
                    <div class="message-time">
                        @TimeZoneInfo.ConvertTimeFromUtc(message.Timestamp, _displayZone).ToString("HH:mm:ss")
                    </div>
                </div>
            </div>
        }

        @if (ChatState.IsProcessing)
        {
            <div class="message-wrapper mb-3 agent-message">
                <div class="message-bubble p-3 rounded">
                    <div class="thinking-indicator">
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                        @if (!string.IsNullOrEmpty(ChatState.CurrentThinkingMessage))
                        {
                            <span>@ChatState.CurrentThinkingMessage</span>
                        }
                        else
                        {
                            <span>Thinking...</span>
                        }
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="chat-input bg-light p-3 border-top">
        <form @onsubmit="SendMessage" @onsubmit:preventDefault="true" class="d-flex gap-2">
            <textarea
                class="form-control"
                placeholder="Type your message..."
                @bind="currentMessage"
                @bind:event="oninput"
                @ref="messageInput"
                @onkeydown="HandleKeyDown"
                disabled="@ChatState.IsProcessing"
                rows="1"
                aria-label="Message input"></textarea>
            <button 
                type="submit" 
                class="btn btn-primary"
                disabled="@(string.IsNullOrWhiteSpace(currentMessage) || ChatState.IsProcessing || !ProxyService.IsConnected)"
                aria-label="Send message">
                Send
            </button>
        </form>
    </div>
</div>

@code {
    private const string SessionId = "blazor-session";
    private const string UserId = "blazor-user";

    private string currentMessage = string.Empty;
    private ElementReference messagesContainer;
    private ElementReference messageInput;
    private bool IsDarkMode = false;
    private TimeZoneInfo _displayZone = TimeZoneInfo.Utc;
    private Action? _stateChangedHandler;
    private Action? _connectionChangedHandler;
    private int _renderedMessageCount = 0;
    private static readonly MarkdownPipeline MarkdownPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    protected override void OnInitialized()
    {
        _stateChangedHandler = () => InvokeAsync(StateHasChanged);
        ChatState.OnStateChanged += _stateChangedHandler;

        _connectionChangedHandler = () => InvokeAsync(StateHasChanged);
        ProxyService.OnConnectionChanged += _connectionChangedHandler;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("chatHelpers.preventEnterNewline", messageInput);
            await JSRuntime.InvokeVoidAsync("chatHelpers.focusInputOnWindowFocus", messageInput);

            var tzId = await JSRuntime.InvokeAsync<string>("chatHelpers.getBrowserTimezone");
            try { _displayZone = TimeZoneInfo.FindSystemTimeZoneById(tzId); }
            catch { _displayZone = TimeZoneInfo.Utc; }

            // Check for system dark mode preference
            IsDarkMode = await JSRuntime.InvokeAsync<bool>("eval",
                "window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches");
            await ApplyDarkMode();

            // Load history after the real SignalR circuit is established.
            // This runs only on first render (never during static prerendering),
            // which avoids a 10-second blank-page wait and prevents duplicate
            // messages when the singleton ChatStateService outlives the component.
            try
            {
                var history = await ProxyService.GetHistoryAsync(SessionId, timeout: TimeSpan.FromSeconds(10));
                if (history is not null && history.Turns.Count > 0)
                    ChatState.LoadHistory(history.Turns, SessionId);
            }
            catch (Exception ex)
            {
                ChatState.AddError($"Could not load conversation history: {ex.Message}");
            }
        }

        // Only scroll when a new message has been added ‚Äî not on every re-render
        // (e.g. theme toggles should not move the scroll position).
        // Scroll to the TOP of the new message so long responses are read top-to-bottom.
        var currentCount = ChatState.Messages.Count;
        if (currentCount > _renderedMessageCount)
        {
            _renderedMessageCount = currentCount;
            await JSRuntime.InvokeVoidAsync("eval",
                "var msgs = document.querySelectorAll('.message-wrapper'); if (msgs.length) msgs[msgs.length - 1].scrollIntoView({ behavior: 'smooth', block: 'start' });");
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage))
            return;

        var messageContent = currentMessage.Trim();
        currentMessage = string.Empty;

        ChatState.AddUserMessage(messageContent, UserId, SessionId);
        ChatState.SetProcessing(true);

        var message = new UserMessage
        {
            Content = messageContent,
            SessionId = SessionId,
            UserId = UserId
        };

        var progressTracker = new Progress<AgentReply>(reply =>
        {
            ChatState.SetThinkingMessage(reply.Content);
        });

        try
        {
            var reply = await ProxyService.SendAsync(message, progress: progressTracker);
            
            if (reply is null)
            {
                ChatState.AddError("No reply received (timeout)");
            }
            else
            {
                ChatState.AddAgentReply(reply);
            }
        }
        catch (Exception ex)
        {
            ChatState.AddError($"Error: {ex.Message}");
        }
        finally
        {
            ChatState.SetProcessing(false);
            await messageInput.FocusAsync();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !e.CtrlKey)
            await SendMessage();
    }

    private string ConvertMarkdownToHtml(string markdown)
    {
        if (string.IsNullOrEmpty(markdown))
            return string.Empty;

        try
        {
            return Markdown.ToHtml(markdown, MarkdownPipeline);
        }
        catch
        {
            // Fallback to plain text if markdown parsing fails
            return System.Net.WebUtility.HtmlEncode(markdown).Replace("\n", "<br/>");
        }
    }

    private async Task ToggleDarkMode()
    {
        IsDarkMode = !IsDarkMode;
        await ApplyDarkMode();
    }

    private async Task ApplyDarkMode()
    {
        await JSRuntime.InvokeVoidAsync("eval", 
            IsDarkMode 
                ? "document.body.classList.add('dark-mode')" 
                : "document.body.classList.remove('dark-mode')");
        StateHasChanged();
    }

    public void Dispose()
    {
        ChatState.OnStateChanged -= _stateChangedHandler;
        ProxyService.OnConnectionChanged -= _connectionChangedHandler;
    }
}
